using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Pql.ClientDriver.Protocol;
using Pql.ExpressionEngine.Interfaces;

namespace Pql.Engine.Interfaces.Internal
{
    /// <summary>
    /// Holder for data of a single row returned or generated by PQL server. 
    /// </summary>
    public sealed class DriverRowData
    {
        private static readonly Dictionary<DbType, Type> s_fieldTypeToNativeType;
        private static readonly Dictionary<Type, DbType> s_nativeTypeToFieldType;
        private static readonly Dictionary<DbType, DataTypeRepresentation> s_fieldStorage;
        private readonly int[] m_fieldCountsByStorageType;

        /// <summary>
        /// Identifier of the entity currently loaded into this data buffer.
        /// </summary>
        public readonly byte[] InternalEntityId;

        /// <summary>
        /// Indexes of field values in corresponding typed arrays. 
        /// </summary>
        public readonly int[] FieldArrayIndexes;

        /// <summary>
        /// NotNulls bitvector, indexes correspond to every field's ordinal.
        /// </summary>
        public readonly int[] NotNulls;
        /// <summary>
        /// Data types, indexes correspond to every field's ordinal.
        /// </summary>
        public readonly DbType[] FieldTypes;
        /// <summary>
        /// Storage types, indexes correspond to every field's ordinal.
        /// </summary>
        public readonly DataTypeRepresentation[] FieldRepresentationTypes;
        /// <summary>
        /// Data for value types up to 8 bytes in size, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        /// /// <seealso cref="FieldArrayIndexes"/>
        public readonly ValueHolder8Bytes[] ValueData8Bytes;
        /// <summary>
        /// Data for value types from 9 to 16 bytes in size, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        /// /// <seealso cref="FieldArrayIndexes"/>
        public readonly ValueHolder16Bytes[] ValueData16Bytes;
        /// <summary>
        /// Data for string types, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        /// <seealso cref="FieldArrayIndexes"/>
        public readonly String[] StringData;
        /// <summary>
        /// Data for binary types, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        /// /// <seealso cref="FieldArrayIndexes"/>
        public readonly SizableArrayOfByte[] BinaryData;

        /// <summary>
        /// Ctr.
        /// </summary>
        /// <param name="fieldTypes">Field metadata, ordered</param>
        public DriverRowData(DbType[] fieldTypes)
        {
            if (fieldTypes == null)
            {
                throw new ArgumentNullException(nameof(fieldTypes));
            }

            InternalEntityId = new byte[byte.MaxValue + 1];

            NotNulls = new int[BitVector.GetArrayLength(fieldTypes.Length)];

            FieldArrayIndexes = new int[fieldTypes.Length];
            FieldRepresentationTypes = new DataTypeRepresentation[fieldTypes.Length];

            m_fieldCountsByStorageType = new int[1 + Enum.GetValues(typeof(DataTypeRepresentation)).Cast<byte>().Max()];

            int count;
            for (var ordinal = 0; ordinal < fieldTypes.Length; ordinal++)
            {
                var dbType = fieldTypes[ordinal];
                var storageType = s_fieldStorage[dbType];
                count = m_fieldCountsByStorageType[(byte)storageType];

                FieldArrayIndexes[ordinal] = count;
                FieldRepresentationTypes[ordinal] = storageType;
                m_fieldCountsByStorageType[(byte)storageType] = count + 1;
            }

            count = m_fieldCountsByStorageType[(int)DataTypeRepresentation.Value8Bytes];
            ValueData8Bytes = count > 0 ? new ValueHolder8Bytes[count] : null;
            count = m_fieldCountsByStorageType[(int)DataTypeRepresentation.Value16Bytes];
            ValueData16Bytes = count > 0 ? new ValueHolder16Bytes[count] : null;
            count = m_fieldCountsByStorageType[(int)DataTypeRepresentation.String];
            StringData = count > 0 ? new String[count] : null;
            count = m_fieldCountsByStorageType[(int)DataTypeRepresentation.ByteArray];
            BinaryData = count > 0 ? new SizableArrayOfByte[count] : null;

            if (BinaryData != null)
            {
                for (var i = 0; i < BinaryData.Length; i++)
                {
                    BinaryData[i] = new SizableArrayOfByte();
                }
            }

            FieldTypes = fieldTypes;
        }

        /// <summary>
        /// Returns index of the field in a typed array.
        /// </summary>
        /// <param name="indexInResponse">Index of the field in the response, irrespective of its data type. Also known as Ordinal: <see cref="DataResponseField.Ordinal"/></param>
        
        public int GetIndexInArray(int indexInResponse)
        {
            return FieldArrayIndexes[indexInResponse];
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public Int64 GetInt64(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsInt64 : 0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public Int32 GetInt32(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsInt32 : 0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public Int16 GetInt16(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsInt16 : (Int16)0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public Byte GetByte(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsByte : (Byte)0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public bool GetBoolean(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) && ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsBoolean;
        }

        /// <summary>
        /// Returns datetime value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public DateTime GetDateTime(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsDateTime : new DateTime();
        }

        /// <summary>
        /// Returns datetime value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public DateTimeOffset GetDateTimeOffset(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData16Bytes[FieldArrayIndexes[indexInResponse]].AsDateTimeOffset : new DateTimeOffset();
        }

        /// <summary>
        /// Returns string value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public string GetString(int indexInResponse)
        {
            if (BitVector.Get(NotNulls, indexInResponse))
            {
                var data = StringData[FieldArrayIndexes[indexInResponse]];
                return data;
            }

            return null;
        }

        /// <summary>
        /// Returns single-character value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        /// <exception cref="DataException">String data must have exactly one character</exception>
        
        public char GetChar(int indexInResponse)
        {
            if (BitVector.Get(NotNulls, indexInResponse))
            {
                var data = StringData[FieldArrayIndexes[indexInResponse]];
                if (data.Length != 1)
                {
                    throw new DataException("Character array length must be equal to 1. Actual length: " + data.Length);
                }

                return data[0];
            }

            return (char)0;
        }

        /// <summary>
        /// Reads a stream of characters from the specified column offset into the buffer as an array, starting at the given buffer offset.
        /// </summary>
        /// <returns>
        /// The actual number of characters read.
        /// </returns>
        /// <param name="ordinal">The zero-based column ordinal. </param><param name="fieldoffset">The index within the row from which to start the read operation. </param>
        /// <param name="buffer">The buffer into which to read the stream of bytes. </param>
        /// <param name="bufferoffset">The index for <paramref name="buffer"/> to start the read operation. </param>
        /// <param name="length">The number of bytes to read. </param>
        /// <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount"/>. </exception>
        /// <filterpriority>2</filterpriority>
        
        public long GetChars(int ordinal, long fieldoffset, char[] buffer, int bufferoffset, int length)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException(nameof(buffer));
            }

            if (fieldoffset > int.MaxValue || fieldoffset < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(fieldoffset));
            }

            if (bufferoffset > int.MaxValue || bufferoffset < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(bufferoffset));
            }

            if (length <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(length));
            }

            if (BitVector.Get(NotNulls, ordinal))
            {
                var data = StringData[FieldArrayIndexes[ordinal]];
                var toCopy = (int)Math.Min(length, Math.Min(buffer.Length - bufferoffset, data.Length - fieldoffset));
                for (var i = 0; i < toCopy; i++)
                {
                    buffer[bufferoffset + i] = data[i];
                }
            }

            return 0;
        }

        /// <summary>
        /// Returns floating point value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public double GetDouble(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsDouble : 0;
        }

        /// <summary>
        /// Returns floating point value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public Single GetSingle(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsSingle : 0;
        }

        /// <summary>
        /// Returns floating point value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public float GetFloat(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsSingle : 0;
        }

        /// <summary>
        /// Returns guid value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public Guid GetGuid(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData16Bytes[FieldArrayIndexes[indexInResponse]].AsGuid : Guid.Empty;
        }

        /// <summary>
        /// Returns binary value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public SizableArrayOfByte GetBinary(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? BinaryData[FieldArrayIndexes[indexInResponse]] : null;
        }

        /// <summary>
        /// Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.
        /// </summary>
        /// <returns>
        /// The actual number of bytes read.
        /// </returns>
        /// <param name="i">The zero-based column ordinal. </param>
        /// <param name="fieldoffset">The index within the field from which to start the read operation. </param>
        /// <param name="buffer">The buffer into which to read the stream of bytes. </param>
        /// <param name="bufferoffset">The index for <paramref name="buffer"/> to start the read operation. </param>
        /// <param name="length">The number of bytes to read. </param>
        /// <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount"/>. </exception>
        /// <filterpriority>2</filterpriority>
        
        public int GetBinary(int i, long fieldoffset, byte[] buffer, int bufferoffset, int length)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException(nameof(buffer));
            }

            if (fieldoffset > int.MaxValue || fieldoffset < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(fieldoffset), fieldoffset, "Invalid offset");
            }

            if (bufferoffset > int.MaxValue || bufferoffset < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(bufferoffset), bufferoffset, "Invalid offset");
            }

            if (length <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(length));
            }

            if (BitVector.Get(NotNulls, i))
            {
                var data = BinaryData[FieldArrayIndexes[i]];
                var toCopy = (int)Math.Min(length, Math.Min(buffer.Length - bufferoffset, data.Length - fieldoffset));
                if (toCopy > 0)
                {
                    Buffer.BlockCopy(data.Data, (int)fieldoffset, buffer, bufferoffset, toCopy);
                    return toCopy;
                }
            }

            return 0;
        }

        /// <summary>
        /// Returns decimal value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        
        public decimal GetCurrency(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData16Bytes[FieldArrayIndexes[indexInResponse]].AsDecimal : 0;
        }

        /// <summary>
        /// Generates an expression that assigns T or Nullable(T) to a slot in DriverRowData, where T is defined by field's DbType.
        /// </summary>
        /// <param name="value">Expression that returns a value to be put into destination row</param>
        /// <param name="rowData">Row data that holds values and NotNull flags</param>
        /// <param name="dbType">Field metadata</param>
        /// <param name="ordinalValue">Ordinal of this field in the row data</param>
        public static Expression CreateWriteAccessor(Expression value, Expression rowData, DbType dbType, int ordinalValue)
        {
            if (rowData == null)
            {
                throw new ArgumentNullException(nameof(rowData));
            }

            switch (dbType)
            {
                //case DbType.VarNumeric:
                //    break;
                case DbType.AnsiStringFixedLength:
                case DbType.StringFixedLength:
                case DbType.Xml:
                case DbType.AnsiString:
                case DbType.String:
                    return CreateWriteAccessor(value, rowData, "StringData", ordinalValue, dbType, null);
                case DbType.Binary:
                case DbType.Object:
                    return CreateWriteAccessor(value, rowData, "BinaryData", ordinalValue, dbType, null);
                case DbType.Byte:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsByte");
                case DbType.Boolean:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsBoolean");
                case DbType.Currency:
                case DbType.Decimal:
                    return CreateWriteAccessor(value, rowData, "ValueData16Bytes", ordinalValue, dbType, "AsDecimal");
                case DbType.Date:
                case DbType.DateTime:
                case DbType.DateTime2:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsDateTime");
                case DbType.Time:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsTimeSpan");
                case DbType.Double:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsDouble");
                case DbType.Guid:
                    return CreateWriteAccessor(value, rowData, "ValueData16Bytes", ordinalValue, dbType, "AsGuid");
                case DbType.Int16:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsInt16");
                case DbType.Int32:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsInt32");
                case DbType.Int64:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsInt64");
                case DbType.SByte:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsSByte");
                case DbType.Single:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsSingle");
                case DbType.UInt16:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsUInt16");
                case DbType.UInt32:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsUInt32");
                case DbType.UInt64:
                    return CreateWriteAccessor(value, rowData, "ValueData8Bytes", ordinalValue, dbType, "AsUInt64");
                case DbType.DateTimeOffset:
                    return CreateWriteAccessor(value, rowData, "ValueData16Bytes", ordinalValue, dbType, "AsDateTimeOffset");
                default:
                    throw new Exception("Invalid data type: " + dbType);
            }
        }

        /// <summary>
        /// Generates an expression that returns Nullable(T) where T is defined by field's DbType.
        /// </summary>
        /// <param name="rowData">Row data that holds values and NotNull flags</param>
        /// <param name="dbType">Field metadata</param>
        /// <param name="ordinalValue">Ordinal of this field in the row data</param>
        public static Expression CreateReadAccessor(Expression rowData, DbType dbType, int ordinalValue)
        {
            if (rowData == null)
            {
                throw new ArgumentNullException(nameof(rowData));
            }

            switch (dbType)
            {
                //case DbType.VarNumeric:
                //    break;
                case DbType.AnsiStringFixedLength:
                case DbType.StringFixedLength:
                case DbType.Xml:
                case DbType.AnsiString:
                case DbType.String:
                    return CreateReadAccessor(rowData, "StringData", ordinalValue, dbType, null);
                case DbType.Binary:
                case DbType.Object:
                    return CreateReadAccessor(rowData, "BinaryData", ordinalValue, dbType, null);
                case DbType.Byte:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsByte");
                case DbType.Boolean:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsBoolean");
                case DbType.Currency:
                case DbType.Decimal:
                    return CreateReadAccessor(rowData, "ValueData16Bytes", ordinalValue, dbType, "AsDecimal");
                case DbType.Date:
                case DbType.DateTime:
                case DbType.DateTime2:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsDateTime");
                case DbType.Time:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsTimeSpan");
                case DbType.Double:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsDouble");
                case DbType.Guid:
                    return CreateReadAccessor(rowData, "ValueData16Bytes", ordinalValue, dbType, "AsGuid");
                case DbType.Int16:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsInt16");
                case DbType.Int32:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsInt32");
                case DbType.Int64:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsInt64");
                case DbType.SByte:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsSByte");
                case DbType.Single:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsSingle");
                case DbType.UInt16:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsUInt16");
                case DbType.UInt32:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsUInt32");
                case DbType.UInt64:
                    return CreateReadAccessor(rowData, "ValueData8Bytes", ordinalValue, dbType, "AsUInt64");
                case DbType.DateTimeOffset:
                    return CreateReadAccessor(rowData, "ValueData16Bytes", ordinalValue, dbType, "AsDateTimeOffset");
                default:
                    throw new Exception("Invalid data type: " + dbType);
            }
        }

        private static Expression CreateReadAccessor(Expression rowData, string valueArrayName, int ordinalValue, DbType dbType, string subFieldName)
        {
            var ordinal = Expression.Constant(ordinalValue);
            var notnulldata = Expression.Field(rowData, "NotNulls");
            var arrayindexdata = Expression.Field(rowData, "FieldArrayIndexes");

            var underlyingType = DeriveSystemType(dbType);
            var indexinarray = Expression.ArrayIndex(arrayindexdata, ordinal);
            Expression fieldValue = Expression.ArrayIndex(Expression.Field(rowData, valueArrayName), indexinarray);

            var isnotnull = Expression.Call(typeof(BitVector), "Get", null, notnulldata, ordinal);

            // value types use Nullable(T) to pass nullability information
            if (fieldValue.Type.IsValueType)
            {
                var nullabletype = typeof(UnboxableNullable<>).MakeGenericType(underlyingType);

                if (subFieldName != null)
                {
                    fieldValue = Expression.Field(fieldValue, subFieldName);
                }

                return Expression.Condition(
                    isnotnull,
                    ExpressionTreeExtensions.MakeNewNullable(nullabletype, fieldValue),
                    ExpressionTreeExtensions.MakeNewNullable(nullabletype));
            }

            // null values of reference types simply take value of null
            return Expression.Condition(isnotnull, fieldValue, Expression.Constant(null, fieldValue.Type));
        }

        private static Expression CreateWriteAccessor(Expression value, Expression rowData, string valueArrayName, int ordinalValue, DbType dbType, string subFieldName)
        {
            var ordinal = Expression.Constant(ordinalValue);
            var notnulldata = Expression.Field(rowData, "NotNulls");
            var arrayindexdata = Expression.Field(rowData, "FieldArrayIndexes");

            var indexinarray = Expression.ArrayIndex(arrayindexdata, ordinal);
            Expression fieldValue = Expression.ArrayAccess(Expression.Field(rowData, valueArrayName), indexinarray);

            var setNotNull = Expression.Call(typeof(BitVector), "Set", null, notnulldata, ordinal);

            // value types use Nullable(T) to pass nullability information
            if (fieldValue.Type.IsValueType)
            {
                if (!value.IsNullableType())
                {
                    throw new Exception("Expected a nullable type, got " + value.Type.FullName);
                }

                if (subFieldName != null)
                {
                    fieldValue = Expression.Field(fieldValue, subFieldName);
                }

                return Expression.IfThen(
                    Expression.Field(value, "HasValue"),
                    Expression.Block(Expression.Assign(fieldValue, Expression.Field(value, "Value")), setNotNull));
            }

            // null values of reference types simply take value of null
            if (dbType == DbType.Object || dbType == DbType.Binary)
            {
                var methodInfo = typeof(SizableArrayOfByte).GetMethod("CopyFrom", new Type[] { typeof(SizableArrayOfByte) });
                return Expression.IfThen(
                    Expression.ReferenceNotEqual(value, Expression.Constant(null, value.Type)),
                    Expression.Block(
                        Expression.Call(fieldValue, methodInfo, value),
                        setNotNull));
            }

            // null values of reference types simply take value of null
            return Expression.IfThen(
                Expression.ReferenceNotEqual(value, Expression.Constant(null, value.Type)),
                Expression.Block(Expression.Assign(fieldValue, value), setNotNull));
        }

        /// <summary>
        /// In-memory representation.
        /// </summary>
        public enum DataTypeRepresentation : byte
        {
            /// <summary>
            /// Array of bytes
            /// </summary>
            ByteArray,
            /// <summary>
            /// String
            /// </summary>
            String,
            /// <summary>
            /// Uses <see cref="ValueHolder8Bytes"/>
            /// </summary>
            Value8Bytes,
            /// <summary>
            /// Uses <see cref="ValueHolder16Bytes"/>
            /// </summary>
            Value16Bytes
        }

        /// <summary>
        /// Universal value holder. Temporary, to reduce complexity.
        /// </summary>
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public struct ValueHolder8Bytes
        {
            /// <summary>
            /// Boolean value.
            /// </summary>
            [FieldOffset(0)]
            public Boolean AsBoolean;

            /// <summary>
            /// Byte value.
            /// </summary>
            [FieldOffset(0)]
            public Byte AsByte;

            /// <summary>
            /// signed byte value.
            /// </summary>
            [FieldOffset(0)]
            public SByte AsSByte;

            /// <summary>
            /// Int64 value.
            /// </summary>
            [FieldOffset(0)]
            public Int64 AsInt64;

            /// <summary>
            /// Unsigned Int64 value.
            /// </summary>
            [FieldOffset(0)]
            public UInt64 AsUInt64;

            /// <summary>
            /// Int16 value.
            /// </summary>
            [FieldOffset(0)]
            public Int16 AsInt16;

            /// <summary>
            /// Unsigned Int16 value.
            /// </summary>
            [FieldOffset(0)]
            public UInt16 AsUInt16;

            /// <summary>
            /// Int32 value.
            /// </summary>
            [FieldOffset(0)]
            public Int32 AsInt32;

            /// <summary>
            /// Unsigned Int32 value.
            /// </summary>
            [FieldOffset(0)]
            public UInt32 AsUInt32;

            /// <summary>
            /// Double (64bit) floating point value.
            /// </summary>
            [FieldOffset(0)]
            public Double AsDouble;

            /// <summary>
            /// Single (32bit) floating point value.
            /// </summary>
            [FieldOffset(0)]
            public Single AsSingle;

            /// <summary>
            /// DateTime (64bit) value.
            /// </summary>
            [FieldOffset(0)]
            public DateTime AsDateTime;

            /// <summary>
            /// TimeSpan (64bit) value.
            /// </summary>
            [FieldOffset(0)]
            public TimeSpan AsTimeSpan;
        }

        /// <summary>
        /// Universal value holder. Temporary, to reduce complexity.
        /// </summary>
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public struct ValueHolder16Bytes
        {
            /// <summary>
            /// Raw data.
            /// </summary>
            [FieldOffset(0)]
            public Int64 Lo;

            /// <summary>
            /// Raw data.
            /// </summary>
            [FieldOffset(8)]
            public Int64 Hi;

            /// <summary>
            /// Decimal-currency (128bit) value.
            /// </summary>
            [FieldOffset(0)]
            public Decimal AsDecimal;

            /// <summary>
            /// Guid (128bit) value.
            /// </summary>
            [FieldOffset(0)]
            public Guid AsGuid;

            /// <summary>
            /// DateTimeOffset (80bit) value.
            /// </summary>
            [FieldOffset(0)]
            public DateTimeOffset AsDateTimeOffset;
        }

        static DriverRowData()
        {
            s_fieldStorage = new Dictionary<DbType, DataTypeRepresentation>
                {
                    {DbType.AnsiString, DataTypeRepresentation.String},
                    {DbType.AnsiStringFixedLength, DataTypeRepresentation.String},
                    {DbType.Binary, DataTypeRepresentation.ByteArray},
                    {DbType.Object, DataTypeRepresentation.ByteArray},
                    {DbType.Boolean, DataTypeRepresentation.Value8Bytes},
                    {DbType.Byte, DataTypeRepresentation.Value8Bytes},
                    {DbType.Currency, DataTypeRepresentation.Value16Bytes},
                    {DbType.Date, DataTypeRepresentation.Value8Bytes},
                    {DbType.DateTime, DataTypeRepresentation.Value8Bytes},
                    {DbType.DateTime2, DataTypeRepresentation.Value8Bytes},
                    {DbType.DateTimeOffset, DataTypeRepresentation.Value16Bytes},
                    {DbType.Decimal, DataTypeRepresentation.Value16Bytes},
                    {DbType.Double, DataTypeRepresentation.Value8Bytes},
                    {DbType.Guid, DataTypeRepresentation.Value16Bytes},
                    {DbType.Int16, DataTypeRepresentation.Value8Bytes},
                    {DbType.Int32,DataTypeRepresentation.Value8Bytes},
                    {DbType.Int64, DataTypeRepresentation.Value8Bytes},
                    {DbType.SByte, DataTypeRepresentation.Value8Bytes},
                    {DbType.Single, DataTypeRepresentation.Value8Bytes},
                    {DbType.String, DataTypeRepresentation.String},
                    {DbType.StringFixedLength, DataTypeRepresentation.String},
                    {DbType.Time, DataTypeRepresentation.Value8Bytes},
                    {DbType.UInt16, DataTypeRepresentation.Value8Bytes},
                    {DbType.UInt32, DataTypeRepresentation.Value8Bytes},
                    {DbType.UInt64, DataTypeRepresentation.Value8Bytes},
                    {DbType.Xml, DataTypeRepresentation.String}
                };

            s_nativeTypeToFieldType = new Dictionary<Type, DbType>
                {
                    {typeof (String), DbType.String},
                    {typeof (SizableArrayOfByte), DbType.Binary},
                    {typeof (Boolean), DbType.Boolean},
                    {typeof (Byte), DbType.Byte},
                    {typeof (Decimal), DbType.Decimal},
                    {typeof (TimeSpan), DbType.Time},
                    {typeof (DateTime), DbType.Date},
                    {typeof (DateTimeOffset), DbType.DateTimeOffset},
                    {typeof (Double), DbType.Double},
                    {typeof (Guid), DbType.Guid},
                    {typeof (Int16), DbType.Int16},
                    {typeof (Int32), DbType.Int32},
                    {typeof (Int64), DbType.Int64},
                    {typeof (SByte), DbType.SByte},
                    {typeof (Single), DbType.Single},
                    {typeof (UInt16), DbType.UInt16},
                    {typeof (UInt32), DbType.UInt32},
                    {typeof (UInt64), DbType.UInt64},
                };

            //FieldTypes.Add(DbType.VarNumeric, null);
            s_fieldTypeToNativeType = new Dictionary<DbType, Type>
                {
                    {DbType.AnsiString, typeof (String)},
                    {DbType.AnsiStringFixedLength, typeof (String)},
                    {DbType.Binary, typeof (SizableArrayOfByte)},
                    {DbType.Object, typeof (SizableArrayOfByte)},
                    {DbType.Boolean, typeof (Boolean)},
                    {DbType.Byte, typeof (Byte)},
                    {DbType.Currency, typeof (Decimal)},
                    {DbType.Date, typeof (DateTime)},
                    {DbType.DateTime, typeof (DateTime)},
                    {DbType.DateTime2, typeof (DateTime)},
                    {DbType.DateTimeOffset, typeof (DateTimeOffset)},
                    {DbType.Decimal, typeof (Decimal)},
                    {DbType.Double, typeof (Double)},
                    {DbType.Guid, typeof (Guid)},
                    {DbType.Int16, typeof (Int16)},
                    {DbType.Int32, typeof (Int32)},
                    {DbType.Int64, typeof (Int64)},
                    {DbType.SByte, typeof (SByte)},
                    {DbType.Single, typeof (Single)},
                    {DbType.String, typeof (String)},
                    {DbType.StringFixedLength, typeof (String)},
                    {DbType.Time, typeof (TimeSpan)},
                    {DbType.UInt16, typeof (UInt16)},
                    {DbType.UInt32, typeof (UInt32)},
                    {DbType.UInt64, typeof (UInt64)},
                    {DbType.Xml, typeof (String)}
                };
        }

        /// <summary>
        /// Attempts to find a system type based on provided logical data type.
        /// </summary>
        /// <param name="dbType">Logical data type</param>
        /// <returns>System type</returns>
        /// <exception cref="ArgumentOutOfRangeException">Unknown data type</exception>
        public static Type DeriveSystemType(DbType dbType)
        {
            if (!s_fieldTypeToNativeType.TryGetValue(dbType, out var result))
            {
                throw new ArgumentOutOfRangeException(nameof(dbType), dbType, "Unknown data type");
            }

            return result;
        }

        /// <summary>
        /// Attempts to find a logical data type based on provided system type.
        /// </summary>
        /// <param name="type">System type</param>
        /// <returns>Logical data type</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null</exception>
        /// <exception cref="ArgumentException">Unsupported type</exception>
        public static DbType DeriveDataType(Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!s_nativeTypeToFieldType.TryGetValue(type, out var result))
            {
                throw new ArgumentException("Unsupported type: " + type.FullName);
            }

            return result;
        }

        /// <summary>
        /// Returns number of bytes needed to store a given value type.
        /// Reference types are not allowed here.
        /// </summary>
        /// <param name="dbType">Value type</param>
        /// <exception cref="ArgumentOutOfRangeException">Type must be a value type</exception>
        public static int GetByteCount(DbType dbType)
        {
            switch (dbType)
            {
                case DbType.Byte:
                case DbType.SByte:
                case DbType.Boolean:
                    return 1;
                case DbType.Date:
                case DbType.DateTime:
                case DbType.DateTime2:
                case DbType.Time:
                case DbType.Int64:
                case DbType.UInt64:
                case DbType.Double:
                    return 8;
                case DbType.Decimal:
                case DbType.Guid:
                case DbType.Currency:
                    return 16;
                case DbType.Int16:
                case DbType.UInt16:
                    return 2;
                case DbType.Int32:
                case DbType.UInt32:
                case DbType.Single:
                    return 4;
                case DbType.DateTimeOffset:
                    return 12;
                default:
                    throw new ArgumentOutOfRangeException(nameof(dbType), dbType, "Type must be a value type");
            }
        }

        public static DataTypeRepresentation DeriveRepresentationType(DbType dbType)
        {
            return s_fieldStorage[dbType];
        }
    }
}